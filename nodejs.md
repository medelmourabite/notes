# NodeJs Interview Questions:

## A. What is Node.js?

### 1. What is Node.js?

Node.js is an open-source, cross-platform, back-end JavaScript runtime environment that runs on the V8 engine and executes JavaScript code outside a web browser.

### 2. What is the difference between a frameworks and a runtime enivronment?

A framework is a set of tools and libraries that are used to develop applications. A runtime environment is a set of tools and libraries that are used to run the code written in a framework.

### 3. What is the difference between Node.js and Express.js?

Node.js is a JavaScript runtime environment that runs on the V8 engine. Express.js is a web framework for Node.js.

### 4. What is the difference between client side(Browser) and server side(Node.js)?

Browsers are used to render HTML pages and CSS styles, and handle interaction with the user. Server-side is used to handle requests from the user and send responses to the user, interact with the database, and perform other tasks.

## B. Main features of Node.js?

### 1. What is the 7 main features of Node.js?

1. Single-threaded
2. Asynchronous
3. Event-driven
4. V8 engine
5. Cross-platform
6. NPM
7. Realtime capabilties

### 2. Single-threaded vs Multi-threaded

It can execute only one task at a time (As oposed to multi-threaded programming, that can cause dead-locking issues if not handled properly).

### 3. Asynchronous vs Synchronous

It allows to execute multiple tasks at the same time, A single thread can execute a task adn not wait for the task to finish to start the next task. (As opposed to synchronous that executes one task after another).

### 4. Events, Emitters, Event queue, Event loop & Event drivern:

The `Event` is a signal generated by an `Event emitter`. it then is stored in an `Event queue`. Then node will pick one event at a time and execute it's `Event handler`. This process is called the `Event loop`.

### 5. Advantages of Node.js

1. Asynchronous: Enables handling of multiple concurrent requests and non blocking execution of thread
2. V8 engine: Enables high performance and low latency
3. Event-Driven: Efficient handling events, great for bidi communication like in chat apps.
4. Cross-Platform: Enables running on multiple platforms
5. NPM: Enables package management with a great variety of libraries

### 6. When to use Node.js?

1. real-time applications
2. server-side scripting
3. Excellent for lightweight and scalable RESTful APIs
4. Well-suited for microservices-based architectures.

### 7. When not to use Node.js?

CPU intensive tasks that requires multiple threads, for example:

1. Background processing
2. Database operations
3. Networking
4. File operations
5. Image/video/audio processing
6. Machine learning
7. Game development

## C. Setup & Modules

### 1. Setup

Install Node.js and NPM and create a new project, then run:

```
$ npm init -y
```

### 2. What is `package.json`:

Contais metadata about the project, including the project name, version, dependencies, scripts, etc.

### 3. What is module:

A module contains a specific functionality that can be easily reused within a Node.js application.
Ideally in Node.js, a JavaScript file is a module.

### 4. How to export a module:

```
module.exports = function f1(){}
// or
exports.f2 = function(){}
```

### 5. How to import a module:

```js
const module = require('module');
const f2 = module('f2);
```

### 6. What ismodule wrapper fucntion:

In Node.js each module is wrapped in a function that is generated auomatically before it is executed.

```js
(function (exports, require, module, __filename, __dirname) {
  // code here
});
```

### 7. type of module:

1. Built-in modules (Core modules like fs, http, path...)
2. Local modules (JS files created by the developer)
3. Third-party modules (Installed using npm)

## D. Top built-in modules in Node.js:

### 1. fs:

Used for managing files and directories.

```js
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log(data);
});

fs.writeFile('file.txt', 'Hello World', 'utf8', (err) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log('File written successfully');
});
// other methods: appendFile, unlink, readdir, mkdir, rmdir, stat...
```

### 2. path:

Provide utilities for joining, resolving, parsing, formatting, and validating file and directory paths.

```js
const path = require('path');

// Joining paths
const fullPath = path.join(__dirname, 'file.txt');
console.log(fullPath);

// Parsing paths
const parsetPathObj = path.parse('/path/to/file.txt');
console.log(parsetPathObj);
/*
{
    root: '/',
    dir: '/path',
    base: 'file.txt',
    ext: '.txt',
    name: 'file'
}
*/
```

### 3. os:

Provide a set of methods for interacting with the operating system.

```js
const os = require('os');

// Get platform name
console.log(os.type()); // 'Linux' or 'Windows_NT'

// Get current user info
console.log(os.userInfo()); // { uid: 1000, gid: 20, username: 'root' }

// Get memory informations
console.log(os.freemem()); // 1024000
console.log(os.totalmem()); // 104857600
```

### 4. events:

Provide a set of methods for emitting and listening to events.

```js
const EventEmitter = require('events');

// Instantiate EventEmitter class
const emitter = new EventEmitter();

// Register a listener with 3 event arguments
emitter.on('eventName', (arg1, arg2, arg3) => {
  console.log('event fired');
  // Do something
});

// Emit an event
emitter.emit('eventName', 'arg1', 'arg2', 'arg3');
```

### 5. http:

Permit to create a server and handle requests.

```js
const http = require('http');

// Create a server
const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end('<h1>Hello World</h1>');
});

// Start the server
server.listen(3000, () => {
  console.log('Server running at http://localhost:3000');
});
```

## E. Error Handling and Debugging:

### 1. What is Error Handling?

It is the process of managing errors in a program.

#### 1.1. Try-catch block (Sync)

```js
try {
  // Synchronous operations
  throw new Error('Error message');
} catch (err) {
  // Handle the error
  console.log('Error: ' + err.message);
} finally {
  // Code that will run after the try-catch block
  console.log('This will always run');
}
```

#### 1.2. Error-First Callback (Async)

The error is the first argument passed to the callback function.

```js
const errorFirstCallback = (err, result) => {
  if (err) {
    console.log(err.message);
    return;
  }
  console.log(result);
};
```

#### 1.3. Promises (Async)

```js
const promise1 = new Promise((resolve, reject) => {
  // Synchronous operations
  if(operationIsSuccessful) {
    resolve('Success');
  } else {
      reject(new Error('Error message'));
  }
});

promise1.then(result =>  {
  console.log(result);
}).catch(err =>  {
  console.log(err.message);
}).finally( => {
  console.log('This will always run');
});
```

#### 1.4. try-catch with async-await (Async)

```js
const asyncFunction = async () => {
  try {
    // run some async operation that might throw an error
    const result = await someAsyncOperation();
    return result;
  } catch (err) {
    console.log(err.message);
  } finally {
    console.log('This will always run');
  }
};
```

### 2. How to debug Node.js code?

1. console.log()
2. debugger
3. node inspect
4. DevTools
